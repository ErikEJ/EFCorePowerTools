<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="bigint" xml:space="preserve">
    <value>Données entières (nombre entier) de –2 ^ 63 (–9 223 372 036 854 775 808) à 2 ^ 63-1 (9 223 372 036 854 775 807).
La taille de stockage est de 8 octets.</value>
  </data>
  <data name="bit" xml:space="preserve">
    <value>Données entières avec une valeur de 1 ou 0.
La taille de stockage est de 1 bit.</value>
  </data>
  <data name="CanNotCreateWindow" xml:space="preserve">
    <value>Impossible de créer la fenêtre d'outil.</value>
  </data>
  <data name="ClassTemplateCsharp" xml:space="preserve">
    <value>using System;
using System.Data.SqlServerCe;
using System.Text;

public class MergeReplication
{
    public static void Synchronize()
    {
        SqlCeReplication repl = new SqlCeReplication();  

#ReplParams#
        try
        {
            repl.AddSubscription(AddOption.ExistingDatabase);
            repl.Synchronize();
        }
        catch (SqlCeException e)
        {
            Console.WriteLine(ShowErrors(e));
        }
    }

    private static string ShowErrors(SqlCeException e)
    {
        SqlCeErrorCollection errorCollection = e.Errors;

        StringBuilder bld = new StringBuilder();
        Exception inner = e.InnerException;

        if (null != inner)
        {
            bld.Append("Inner Exception: " + inner.ToString());
        }
        foreach (System.Data.SqlServerCe.SqlCeError err in errorCollection)
        {
            bld.Append("\n Error Code: " + err.HResult.ToString("X", System.Globalization.CultureInfo.InvariantCulture));
            bld.Append("\n Message   : " + err.Message);
            bld.Append("\n Minor Err.: " + err.NativeError);
            bld.Append("\n Source    : " + err.Source);
            // Enumerate each numeric parameter for the error.
            foreach (int numPar in err.NumericErrorParameters)
            {
                if (0 != numPar) bld.Append("\n Num. Par. : " + numPar);
            }
            // Enumerate each string parameter for the error.
            foreach (string errPar in err.ErrorParameters)
            {
                if (!string.IsNullOrEmpty(errPar)) bld.Append("\n Err. Par. : " + errPar);
            }
        }
        return bld.ToString();
    }

}</value>
  </data>
  <data name="integer" xml:space="preserve">
    <value>Données entières (nombre entier) de –2 ^ 31 (–2 147 483 648) à 2 ^ 31-1 (2 147 483 647).
La taille de stockage est de 4 octets.</value>
  </data>
  <data name="money" xml:space="preserve">
    <value>Valeurs des données monétaires de (–2 ^ 63/10000) (–922,337,203,685,477,5808) à 2 ^ 63-1 (922,337,203,685,477,5807), avec une précision au dix-millième d'unité monétaire.
La taille de stockage est de 8 octets</value>
  </data>
  <data name="numeric" xml:space="preserve">
    <value>Données numériques à précision fixe et échelle de –10 ^ 38 + 1 à 10 ^ 38–1. La variable p spécifie la précision et peut varier entre 1 et 38. La variable s spécifie l'échelle et peut varier entre 0 et p.
La taille de stockage est de 19 octets.</value>
  </data>
  <data name="smallint" xml:space="preserve">
    <value>Données entières comprises entre –32 768 et 32 767.
La taille de stockage est de 2 octets.</value>
  </data>
  <data name="tinyint" xml:space="preserve">
    <value>Données entières de 0 à 255.
La taille de stockage est de 1 octet.</value>
  </data>
  <data name="ToolWindowTitle" xml:space="preserve">
    <value>Boîte à outils SQLite/SQL Server Compact</value>
  </data>
  <data name="binary" xml:space="preserve">
    <value>Données binaires de longueur fixe d'une longueur maximale de 8000 octets. Longueur par défaut = 1.
La taille de stockage est fixe, c'est-à-dire la longueur en octets déclarée dans le type.</value>
  </data>
  <data name="datetime" xml:space="preserve">
    <value>Données de date et d'heure du 1er janvier 1753 au 31 décembre 9999, avec une précision de trois centièmes de seconde, soit 3,33 millisecondes. Les valeurs sont arrondies par incréments de .000, .003 ou .007 millisecondes.
Stocké sous forme de deux entiers de 4 octets.
Les 4 premiers octets stockent le nombre de jours avant ou après la date de base, le 1er janvier 1900. La date de base est la date de référence du système.
Les valeurs datetime antérieures au 1er janvier 1753 ne sont pas autorisées. Les 4 autres octets stockent l'heure du jour représentée par le nombre de millisecondes après minuit. Les secondes ont une plage valide de 0 à 59.</value>
  </data>
  <data name="floating" xml:space="preserve">
    <value>Données numériques à virgule flottante de –1,79E +308 à 1,79E + 308.
La taille de stockage est de 8 octets.</value>
  </data>
  <data name="image" xml:space="preserve">
    <value>Données binaires de longueur variable d'une longueur maximale de 2 ^ 30–1 (1 073 741 823) octets.
Le stockage est la longueur de la valeur en octets.</value>
  </data>
  <data name="nchar" xml:space="preserve">
    <value>Données Unicode de longueur fixe d'une longueur maximale de 4 000 caractères. Longueur par défaut = 1.
La taille de stockage, en octets, correspond à deux fois le nombre de caractères saisis.</value>
  </data>
  <data name="ntext" xml:space="preserve">
    <value>Données Unicode de longueur variable d'une longueur maximale de (2 ^ 30–2) / 2 (536 870 911) caractères.
La taille de stockage, en octets, correspond à deux fois le nombre de caractères saisis.</value>
  </data>
  <data name="nvarchar" xml:space="preserve">
    <value>Données Unicode de longueur variable d'une longueur de 1 à 4 000 caractères. Longueur par défaut = 1.
La taille de stockage, en octets, correspond à deux fois le nombre de caractères saisis.</value>
  </data>
  <data name="real" xml:space="preserve">
    <value>Données numériques de précision flottantes de –3,40E + 38 à 3,40E + 38.
La taille de stockage est de 4 octets.</value>
  </data>
  <data name="rowversion" xml:space="preserve">
    <value>Il s'agit d'un numéro binaire unique généré automatiquement. *
La taille de stockage est de 8 octets.</value>
  </data>
  <data name="uniqueidentifier" xml:space="preserve">
    <value>Un identifiant global unique (GUID).
La taille de stockage est de 16 octets.</value>
  </data>
  <data name="varbinary" xml:space="preserve">
    <value>Données binaires de longueur variable d'une longueur maximale de 8000 octets. Longueur par défaut = 1.
La taille de stockage varie. C'est la longueur de la valeur en octets.</value>
  </data>
  <data name="SqlCompact35InvariantName" xml:space="preserve">
    <value>System.Data.SqlServerCe.3.5</value>
  </data>
  <data name="SqlCompact35Provider" xml:space="preserve">
    <value>7c602b5b-accb-4acd-9dc0-ca66388c1533</value>
  </data>
  <data name="SqlServerDotNetProvider" xml:space="preserve">
    <value>91510608-8809-4020-8897-fba057e22d54</value>
  </data>
  <data name="SQLiteInvariantName" xml:space="preserve">
    <value>System.Data.SQLite</value>
  </data>
  <data name="App" xml:space="preserve">
    <value>SQLite/SQL Server Compact Toolbox</value>
  </data>
  <data name="SQLiteEF6InvariantName" xml:space="preserve">
    <value>System.Data.SQLite.EF6</value>
  </data>
  <data name="NpgsqlProvider" xml:space="preserve">
    <value>70ba90f8-3027-4aF1-9b15-37abbd48744c</value>
  </data>
  <data name="MysqlVSProvider" xml:space="preserve">
    <value>c6882346-e592-4da5-80ba-d2eadcda0359</value>
  </data>
  <data name="OracleProvider" xml:space="preserve">
    <value>9D8FDBB9-EE60-4787-B7AE-49831D34AD4B</value>
  </data>
</root>